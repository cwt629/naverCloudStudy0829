-- 2023-09-20
-- sal이 1000~2000 사이 출력
select ename, sal, comm from emp where sal >= 1000 and sal <= 2000; -- 방법1
select ename, sal, comm from emp where sal BETWEEN 1000 and 2000; -- 방법2

-- sal이 1000~2000을 제외하고 출력
select ename, sal, comm from emp where sal not BETWEEN 1000 and 2000; -- 방법1
select ename, sal, comm from emp where sal < 1000 or sal > 2000; -- 방법2

-- comm이 null인 데이터 조회
select * from emp where comm is null;
-- comm이 null이 아닌 데이터 조회
select * from emp where comm is not null;
-- comm이 null인 경우 0으로 출력, 마지막 컬럼에 sal + comm을 더한 값을 출력
select ename, sal, comm, sal+comm from emp; -- 숫자 + null = null
-- NVL(컬럼명, 값) : 해당 컬럼 값이 null이면 0으로 출력(Oracle은 NVL, mysql에는 isnull)
select ename, sal, NVL(comm, 0), sal + NVL(comm, 0) from emp;

-- 나중에 자바로 가져갈 경우 컬럼 인덱스나 컬럼명으로 가져간다.
-- 그래서 컬럼명이 복잡한 경우, 별칭을 지정한다.
-- 여기서는 큰따옴표 사용
select ename as "사원명", sal as "연봉" from emp; -- "별칭". 공백이 없을 경우 따옴표 생략 가능
select ename 사원명, sal 연봉 from emp; -- 보통 이렇게 간단하게 쓴다고...
select empno "사원 번호", sal 연봉 from emp; -- 별칭에 공백이 있다면 반드시 "" 안에 넣기(as는 생략 가능)

select ename 사원명, sal 연봉, NVL(comm, 0) 수수료, sal + NVL(comm, 0) 총연봉 from emp;

-- 총 글갯수 출력
select count(*) from emp;
select count(*) count from emp;

-- 문자열을 이어서 출력 : || (컬럼명은 member로 출력해보자)
select ename||'님의 직업은 '||job||'입니다' member from emp;

-- 문제:
-- xx 님의 총 연봉은 xxx 입니다 (sal+comm, null인 경우 100으로 계산. 제목은 회원 연봉
-- 주의: 더하기같은 연산이 중간에 있다면 괄호로 묶어줘야 한다
select ename||'님의 총 연봉은 '||(sal + NVL(comm, 100))||'입니다' "회원 연봉" from emp;

-- empno 여러개 조회
select empno, ename from emp where empno = 7369 or empno = 7788 or empno = 7900;

-- 여러개 조회 시 in을 사용할 수 있다
select empno, ename from emp where empno in (7369, 7788, 7900);

-- 위 3개의 empno을 제외하고 출력
select empno, ename from emp where empno not in (7369, 7788, 7900);

-- 문제: ename, job을 출력하는데 job이 SALESMAN이거나 ANALYST, MANAGER 3개의 직업만 출력
select ename, job from emp where job in ('SALESMAN', 'ANALYST', 'MANAGER');

-- 날짜로 조건
select * from emp where hiredate = '80/12/17';
select * from emp where hiredate = '1980-12-17';
select * from emp where hiredate >= '1980-01-01' and hiredate <= '1981-10-10';

-- 현재 날짜 조회
select sysdate from dual; -- 현 콘솔에 출력할 때 dual 사용
-- 내일 날짜
select sysdate + 1 from dual;
-- to_char 변환함수를 이용해서 조회
select to_char(sysdate, 'yyyy-mm-dd') from dual;
select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual; -- 24시기준 시간도 출력(mi: 분, mm: 월)
select to_char(sysdate, 'yyyy-mm-dd am hh:mi') from dual; -- 오전오후 표시(am이든 pm이든 쓰면 됨)
select to_char(sysdate, 'yyyy-mm-dd') from dual;

-- emp에서 ename, hiredate를 출력하되
-- hiredate는 yyyy-mm-dd 형태로,
-- 1981년에 입사한 사람만 출력
-- 제목은 사원명, 입사일
select ename 사원명, to_char(hiredate, 'yyyy-mm-dd') 입사일 from emp where to_char(hiredate, 'yyyy') = 1981; -- '1981'도, 1981도 가능

-- 그룹 함수: count, max, min, avg, sum 등...
select count(*) from emp; -- 전체 데이터 개수
select avg(sal) from emp; -- sal의 평균 (2073.21428571...)
select round(avg(sal), 1) from emp; -- 보통 평균을 구할때는 round 함수와 같이 사용한다 (2073.2)
select round(avg(sal), 0) from emp; -- 2073
select round(avg(sal), -1) from emp; -- 2070
select round(avg(sal), -2) from emp; -- 2100

select sum(sal) from emp; -- sal의 총 합계(29025)
select min(sal) from emp; -- 제일 적은 급여
select max(sal) from emp; -- 제일 큰 급여

-- 문제: 제일 작은 급여를 받는 사람의 이름을 출력해보자(서브쿼리 이용)
select ename, sal from emp where sal = (select min(sal) from emp);
-- 제일 큰 급여를 받는 사람의 이름
select ename, sal from emp where sal = (select max(sal) from emp);

-- 문제: scott의 직업과 같은 직업을 가진 사람들 조회(ename, job, sal)
select ename, job, sal from emp where job = (select job from emp where ename = 'SCOTT');
-- allen보다 더 높은 연봉을 받는 사람의 인원수는?
select count(*) from emp where sal > (select sal from emp where ename = 'ALLEN');

-- group by
-- job(직업)별로 일단 인원수를 구해보자
select job 직업, count(*) 인원수 from emp group by job;
-- 위의 결과를 직업의 오름차순으로 출력
select job 직업, count(*) 인원수 from emp group by job order by 직업;
select job 직업, count(*) 인원수 from emp group by job order by 1; -- 인덱스로(인덱스는 1부터 시작)
-- 인원수의 오름차순으로 출력
select job 직업, count(*) 인원수 from emp group by job order by 인원수;
select job 직업, count(*) 인원수 from emp group by job order by 2;

-- 직업별로 인원수, 평균연봉과 최저연봉, 최고연봉 출력해보자
select job 직업, count(*) 인원수, round(avg(sal), 0) 평균연봉, max(sal) 최고연봉, min(sal) 최저연봉
from emp
group by job;

-- 그룹에 대한 조건을 줄 경우 having 이용
-- 위의 SQL문에 인원수가 3명 이상인 그룹만 출력
select job 직업, count(*) 인원수, round(avg(sal), 0) 평균연봉, max(sal) 최고연봉, min(sal) 최저연봉
from emp
group by job having count(*) >= 3;

-- Oracle 함수들
-- 숫자함수
select abs(-5), abs(5) from dual; -- ABS : 절대값으로 출력
select ceil(2.1), ceil(2.9) from dual; -- ceil(숫자) : 무조건 올림
select floor(2.1), floor(2.9) from dual; -- floor(숫자) : 무조건 내림
select mod(7,2) from dual; -- mod : 나머지
select power(2, 3) from dual; -- power: 거듭제곱(2의 3승)

-- 변환함수
select '7' + 7 from dual; -- 사실 이렇게 해도 나옴
select to_number('7') + 7 from dual; -- 원래 이렇게 하지만...의미가 크게 없는듯 하다
select to_char(sysdate, 'yyyy-mm-dd') from dual;

-- 문자함수
select concat('hello', 'world') from dual; -- 문자열 합치기(mysql은 3개 이상 되는데, Oracle은 2개밖에 안됨...)
select 'hello'||'world' from dual; -- 이렇게 하면 돼서 concat을 굳이 안써도 됨

-- 나중에 자바에서 단어입력하면 그 단어를 포함한 게시물을 출력한다고 가정하면... 이런 식으로 줄 것이다
select * from board where subject like '%'||변수명||'%'; -- 오라클
select * from board where subject like concat('%', 변수명, '%'); -- mySQL

select LPAD(23500, 10, '*') from dual; -- 총 10자리 중 남는 왼쪽 자리는 *로 채우기
select RPAD(23500, 10, '*') from dual; -- 총 10자리 중 남는 오른쪽 자리는 *로 채우기

select INITCAP('HELLO') from dual; -- 첫글자만 대문자로
select LOWER('HELLO') from dual; -- 모든글자 소문자로
select UPPER('HELLO') from dual; -- 모든글자 대문자로

select initcap(ename), lower(ename), upper(ename) from emp;

select substr('HELLO KITTY', 3, 3) from dual; -- 3번째 글자부터 3글자 추출
select substr('HELLO KITTY', -3, 3) from dual; -- 뒤에서 3번째 글자부터 3글자 추출

-- 문제: ename, sal 출력 
-- ename은 두글자만 추출해서 출력 후 뒤에 '***' 붙여서 출력
-- sal은 총 7자리로 출력하되 앞에 '*'로 채워서 출력
select concat(substr(ename, 1, 2), '***') 이름, lpad(sal, 7, '*') 연봉 from emp;
select substr(ename, 1, 2)||'***' 사원명, lpad(sal, 7, '*') 연봉 from emp; -- 선생님 풀이

-- 양쪽 공백 제거
select '*'||'   HELLO    '||'*' from dual;
select '*'||trim('   HELLO    ')||'*' from dual;

select decode(3,1,'ONE',2,'TWO',3,'THREE',4,'FOUR') from dual; -- 첫번째 인자는 값으로, 그 값이 무엇이면 뭐라고 출력하는지 뒤에 순차적으로 나열
select ename, deptno, decode(deptno, 10, '부산', 20, '대구', 30, '제주도') from emp;

-- 문제풀기
--1. emp테이블에서 ename a나 s로 시작하는사람 출력(대소문자 상관없음)
select ename from emp where upper(ename) like 'A%' or upper(ename) like 'S%';

--2. emp테이블에서 ename 에서 두번째 글자가 'A' 인사람 출력
select * from emp where ename like '_A%';

--3. job 에서 같은 직업군일경우 한번씩만 출력하시오(오름차순으로 출력)
select distinct job from emp order by job asc;
  
--4. job 종류별로 인원수를 구하시오(인원수의 내림차순으로 출력)
select job, count(*) cnt from emp group by job order by cnt desc;

--5. job 종류별로 sal 의 평균급여를 구하시오,평균급여의 오름차순으로 출력
select job, round(avg(sal), 0) average from emp group by job order by average asc;

--6. job 종류별로 sal 의 최대값과 최소값을 구하시오
select job, max(sal) 최대연봉, min(sal) 최소연봉 from emp group by job;

--7. deptno 가 10인경우 '홍보부'
--   20 인경우 '개발부' 30인경우 '관리부' 부서를 구하여
--   ename, 부서 를 출력하시오
select ename, deptno, decode(deptno, 10, '홍보부', 20, '개발부', 30, '관리부') 부서 from emp;
  
--8. 급여(sal)가 sal 의 평균보다 더 높은 사람만 ename 과 sal 을 출력하시오
select ename, sal from emp where sal > (select avg(sal) from emp);

--9. hiredate 에서 월이 5월인 사람만 ename 과 hiredate 를 출력하시오
select ename, hiredate from emp where to_char(hiredate, 'mm') = 5;

--10. SCOTT 의 급여와 동일하거나 더 많이 받는 사원명과 급여를 출력하라
select ename, sal from emp where sal >= (select sal from emp where ename = 'SCOTT');