-- 2023.09.21 DB 정규화

-- DB 정규화(Normalization)
-- 정규화 : 한마디로 DB 서버의 메모리를 낭비하지 않기 위해,
--         어떤 테이블을 식별자를 가지는 여러개의 테이블로 나누는 과정
-- 정규화된 데이터베이스는 중복이 최소화되도록 설계된 데이터베이스이다.
--
-- 장점: 메모리 절약, 구조화된 시스템으로 인해 관리 편함
-- 단점: 조회 비율이 매우 높은 시스템에서는 테이블간 join 연산이 반복 -> 질의 응답 속도 살짝 늦어짐

-- student의 num을 외부키로 갖는 새로운 테이블 stuinfo 를 만들어보자
-- 외부키(foreign key)는 테이블 생성 시에 설정해도 되고, 나중에 설정해도 된다.

create table stuinfo (
    idx number(5) constraint stuinfo_pk_idx primary key,
    num number(5),
    addr varchar2(20),
    hp varchar2(20)
);

-- student의 num을 외부키로 설정(ppt 29p)
-- 주의: student의 num은 반드시 primary key여야 한다.
-- (다른 테이블에서 외부키로 쓰려면 그 컬럼은 primary key여야 한다)
alter table stuinfo add constraint stuinfo_fk_num foreign key(num) references student(num);

-- stuinfo에 데이터 추가해보자 (없는 번호인 9번으로 insert 시 어떤 오류가 나는지 확인 필요
-- 오류 메세지: 무결성 제약조건(ANGEL.STUINFO_FK_NUM)이 위배되었습니다- 부모 키가 없습니다
-- student 테이블이 부모테이블: 거기에 num 9가 없어서 오류
insert into stuinfo values (seq_stu.nextval, 9, '서울시 강남구', '010-2323-4545');
-- 만약 김말자의 정보일경우 김말자의 num이 3이므로 3으로 추가해야만 한다
insert into stuinfo values (seq_stu.nextval, 3, '서울시 강남구', '010-2323-4545'); -- 이승기
insert into stuinfo values (seq_stu.nextval, 6, '제주도', '010-1234-1234'); -- 영숙
insert into stuinfo values (seq_stu.nextval, 8, '부산', '010-8989-7878'); -- 영자

-- stuinfo 만 조회
select * from stuinfo;

-- student 만 조회
select * from student;

-- 개인정보가 등록된 학생에 한해서 모든 정보를 출력해보자(inner join, equi join)
select
    stu.name, stu.java, stu.spring, stu.ban, info.addr, info.hp
from student stu, stuinfo info
where stu.num = info.num;

-- 컬럼명 앞에 무조건 어느 테이블 소속인지 붙였는데,
-- 같은 컬럼명이 양쪽 모두 있는게 아니라면 생략해도 됨
select
    stu.num, name, java, spring, ban, addr, hp
from student stu, stuinfo info
where stu.num = info.num;

-- 개인정보가 등록되어 있지 않은 학생들을 출력해보자 (outer join)
-- sub table dp (+) : 등록 안된 컬럼은 null값으로 출력 << 여기서 sub table은 stuinfo다!
select
    stu.name, stu.java, stu.spring, stu.ban, info.addr, info.hp
from student stu, stuinfo info
where stu.num = info.num(+);

-- 위의 결과에 null인 학생만 출력
select
    stu.name, stu.java, stu.spring, stu.ban, info.addr, info.hp
from student stu, stuinfo info
where stu.num = info.num(+) and info.addr is null;

-- sub테이블(stuinfo)에 연결된 데이터가 있는데 부모테이블(student)의 해당 데이터를 삭제하고자 하면?
-- error: 무결성 제약조건(ANGEL.STUINFO_FK_NUM)이 위배되었습니다- 자식 레코드가 발견되었습니다
delete from student where num = 3; -- 오류
delete from student where num = 7; -- stuinfo에 데이터가 없으므로 잘 지워짐

-- 그러면 student의 3번 데이터를 지우려면?
-- 자식 테이블(stuinfo)의 3번 데이터(num = 3) 먼저 삭제 후, student에서 삭제하면 된다.
delete from stuinfo where num = 3; -- 자식테이블 먼저 삭제
delete from student where num = 3; -- 이후 부모테이블 삭제

-- 부모 테이블 drop
-- error: 외래 키에 의해 참조되는 고유/기본 키가 테이블에 있습니다
drop table student;

-- 자식 테이블은 삭제 됨? -> ㅇㅇ
drop table stuinfo;

-------------------------------------------------------------------------------------------
-- 1) 상품 정보를 담을 shop 테이블
-- 2) 장바구니에 담을 cart 테이블
-- 위 두 테이블을 만드는데, 상품정보 저장을 위해서 shop의 num을 외부키로 설정
-- 상품을 삭제하면 장바구니의 해당 데이터가 자동으로 삭제되게 하고 싶다면?
-- on delete cascade 설정해보자.

-- 시퀀스도 새로 하나 만들어보자.
create sequence seq_shop start with 10 nocache;

-- shop table 생성
create table shop (
    sang_no number(5) constraint shop_pk_no primary key,
    sang_name varchar2(100),
    sang_price number(7),
    sang_color varchar2(20)
);

-- 외부키로 연결된 cart 테이블 생성 
-- shop의 상품을 지우면 장바구니 목록은 자동으로 지워지도록, cascade를 설정해서 생성해보자
create table cart (
    cart_no number(5) constraint cart_pk_no primary key,
    sang_no number(5),
    cnt number(5),
    cartday date
);

alter table cart add constraint cart_fk_shopno foreign key(sang_no) references shop(sang_no) on delete cascade;
-- model (ERD) 확인해보기

-- 5개의 상품 등록해보자
insert into shop values (seq_shop.nextval, '블라우스', 23000, 'yellow');
insert into shop values (seq_shop.nextval, '청바지', 45000, 'black');
insert into shop values (seq_shop.nextval, '브이넥티', 11000, 'white');
insert into shop values (seq_shop.nextval, '브이넥티', 23000, 'red');
insert into shop values (seq_shop.nextval, '체크자켓', 130000, 'gray');
commit;

-- cart에 블라우스, 흰색 브이넥티, 체크자켓 총 3개 추가해보기(날짜는 현재 날짜 - sysdate)
insert into cart values (seq_shop.nextval, 10, 1, sysdate);
insert into cart values (seq_shop.nextval, 12, 1, sysdate);
insert into cart values (seq_shop.nextval, 14, 1, sysdate);
commit;
-- 조회(inner join)
-- 상품명, 가격, 색상, 개수, 구입일(yyyy-mm-dd hh24:mi)
select sang_name 상품명, sang_price 가격, sang_color 색상, cnt 개수, to_char(cartday, 'yyyy-mm-dd hh24:mi') 구입일
from shop, cart
where shop.sang_no = cart.sang_no;

-- 아무도 cart에 담지 않은 상품명 조회
-- 상품명, 가격, 색상 출력
select sang_name 상품명, sang_price 가격, sang_color 색상
from shop, cart
where shop.sang_no = cart.sang_no(+) and cart.sang_no is null;

-- cascade를 지정했으므로 cart에 담긴 상품도 삭제가 된다(이 때 cart도 자동으로 지워짐
delete from shop where sang_no = 10;

-- 부모 테이블 drop은 되나? -> 안됨.
drop table shop; -- error

-- 테이블 삭제 시에는 sub테이블을 먼저 제거 후 부모 테이블 제거
drop table cart;
drop table shop;

-- 시퀀스도 지워보자
drop sequence seq_shop;

-----------------------------------------------------------------------------
-- 문제
-- 시퀀스 : seq_food 생성
-- 레스토랑의 메뉴 테이블 (테이블명: food)
-- 컬럼: food_num 숫자(5) 기본키, fname 문자열(20)(메뉴명), fprice 숫자(7)(가격)
create sequence seq_food start with 1 nocache;
create table food (
    food_num number(5) constraint food_pk_num primary key,
    fname varchar2(20),
    fprice number(7)
);

-- sub테이블 : 고객 테이블(person)
-- 컬럼: person_num 숫자(5) 기본키, food_num 외부키 설정(cascade 설정), 
-- person_name 문자열(10)(고객명) , bookingday date타입 (예약일)
create table person(
    person_num number(5) constraint person_pk_num primary key,
    food_num number(5),
    person_name varchar2(10),
    bookingday date
);
alter table person add constraint person_fk_foodno foreign key(food_num) references food(food_num) on delete cascade;

-- food에 5개의 메뉴 등록하자(스파게티, 떡볶이 등등)
insert into food values (seq_food.nextval, '스파게티', 9000);
insert into food values (seq_food.nextval, '떡볶이', 6000);
insert into food values (seq_food.nextval, '게살버거', 8500);
insert into food values (seq_food.nextval, '마라샹궈', 15000);
insert into food values (seq_food.nextval, '민초볶음밥', 12000);
commit;

-- 주문한 고객정보를 추가해보자(같은 메뉴를 여러명이 주문하기도 한다)
insert into person values (seq_food.nextval, 1, '장원태', sysdate);
insert into person values (seq_food.nextval, 2, '강짱돌', '2023-08-30');
insert into person values (seq_food.nextval, 3, '징징이', sysdate - 1);
insert into person values (seq_food.nextval, 1, '아이유', '2023-09-15');
insert into person values (seq_food.nextval, 4, '장원태', sysdate);
insert into person values (seq_food.nextval, 3, '뚱이', '2023-06-29');

-- 조회 : 시퀀스번호, 주문자명, 음식명, 가격, 예약일 (제목도 한글로 추가)
select f.food_num 메뉴번호, person_num 주문번호, person_name 주문자명, fname 음식명, fprice 가격, 
    to_char(bookingday, 'yyyy-mm-dd') 예약일
from food f, person p
where f.food_num = p.food_num;

-- 메뉴 중 스파게티를 삭제 시, 주문한 테이블에서도 지워지는지 확인
select * from person;
delete from food where fname = '스파게티';

